HISTÓRIA DO ECMASCRIPT-6
------------------------
- Criado em 1995 por Brendan Eich (Netscape)


- ECMA: European Computer Manufactorer Association
    - Especificação de como as principais partes da linguagem JavaScript devem ser implementadas pelos "browsers"

    - ES5 foi a versão padronizada em 2009 e a mais significativa

    - ES6 foi desenvolvida em 2015 e tem sido muito utilizada:
        - Os browsers estavam atrasados em relação ao avanço da linguagem, por isso era necessário utilizar "transpilers" para traduzir o ES6 para o ES5



DECLARAÇÃO DE VARIÁVEIS - FUNDAMENTOS DO ES6
--------------------------------------------
- Operadores de declaração de variáveis:
    - Escopos global, função e bloco

    - var: foi descontinuado, mas ainda existe para manter aplicações antigas. O tipo var é regido por uma antiga regra de hierarquia de escopos

    - let: preserva o escopo onde foi criado, sendo inacessível para outros escopos

    - const: não sofre alteração após ser declarada (constante) e também preserva o escopo onde foi criado



TEMPLATE STRING - FUNDAMENTOS DO ES6
------------------------------------
- Template string é um recurso para concatenação ou interpolação de codificação javascript com "strings":
    - Apresenta-se como `${}`:
        - let nome = "Gabriel"
          console.log(`Olá, ${nome}. Tudo bem ?`)
        
        - Dados JS permanecem dentro dos ${}, enquanto as "strings" ficam fora
        
    - Diferente das aspas, é possível realizar quebra de linha:
        - let nome = "Gabriel"
          console.log(`Olá, ${nome}. 
          Seja bem-vindo !
          Espero que esteja bem.`)

    - Permite executar funções:
        - function calcular(a, b) {
            return a + b
          }
          console.log(`A soma entre 2+2 é igual a ${calcular(2, 2)}`)



FUNÇÕES - FUNDAMENTOS DO ES6
----------------------------
- Parâmetros "default" são utilizados na assinatura da função:
    - function historia(nome = "Gabriel", time = "SPFC") {
        document.write(`O ${nome} ama o ${time}`)
      }
      historia()   -> Dessa forma é utilizado os parâmetros da assinatura da função

    - function historia(nome, time) {
        document.write(`O ${nome} ama o ${time}`)
      }
      historia("Gabriel", "SPFC")   -> Dessa forma valores dos parâmetros são passados na execução da função

    - function historia(nome = "Gabriel", time = "SPFC") {
        document.write(`O ${nome} ama o ${time}`)
      }
      historia("Tutiara", undefined)   -> Dessa forma o primeiro parâmetro da assinatura da função é sobrescrito e o segundo é mantido


- Arrow function é uma função com a ideia de flecha. Veja a sintaxe:
    - Antigamente era só conhecida como função anônima, ou seja, sem nome:
        - let quadrado = function(x) {
            return x * x
          }
          console.log(quadrado(3))

    - Atualmente a "arrow function", ou também função anônima, aparece da seguinte forma:
        - let quadrado = (x) => {   --> O sinal "=>" retoma a ideia de uma flecha e não é mais necessário o uso da palavra "function"
            return x * x
          }
          console.log(quadrado(3))
        
        - O uso do parenteses se torna opcional quando houver apenas um parâmetro:
          let quadrado = x => {
            return x * x
          }
          console.log(quadrado(3))

    - Outros exemplos:
        - O uso do "return" também se torna opcional quando não houver lógica extensa ou blocos de código:
          let quadrado = x => x * x
          console.log(quadrado(3))

        - O "return" também pode ser substituído em alguns casos:
          let parOuImpar = numero => numero % 2 === 0 ? "par" : "ímpar"
          console.log(parOuImpar(10))



INTRODUÇÃO A ORIENTAÇÃO A OBJETOS - FUNDAMENTOS DO ES6
------------------------------------------------------
- Procedural, estruturado e imperativo:
    - São paradigmas chamados de procedimentos (procedures) para manipulação de dados, sendo divididos em lógico e funcional:
      let a = 10
      let b = 7
      let operador = "multiplicador"
      function calcular(a, b, operador) {
        if(operador === "multiplicador") {
            console.log(a * b)
        }
      }
      calcular(a, b, operador)

- Orientado a objetos:
    - Também são paradigmas estruturados de dados, divididos em concorrente e reativo, porém, com comportamentos diferentes:
      class Calculadora {
        constructor() {
            this.a = 10
            this.b = 7
            this,operador = "multiplicador"
        }
        calcular() {
            if(this.operador === "multiplicador") {
                console.log(this.a * this.b)
            }
        }
      }
      calculadora = new Calculadora()
      calculadora.calcular()

    - Além disso, o paradigma de OO, possui quatro fundamentos:
        - Abstração: é a capacidade de abstrair elementos do mundo real para a programação

        - Encapsulamento: tornam os atributos e métodos mais seguros, além de facilitar a implementação e alteração dos dados e de
          forma reutilizável

        - Herança: colabora para o código ser reutilizável, menos redundante e de fácil manutenção

        - Poliformismo

    - A abstração é composta por:
        - Entidade:
            - Carro
            - Conta bancária

        - Identidade:
            - x = new Carro()
            - y = new ContaBancaria()

        - Características (atributos):
            - Marca, modelo, cor e quantidade de portas
            - Agência, número da conta, saldo e limite

        - Ações (métodos):
            - Ligar, desligar, acelerar e freiar
            - Depositar, sacar e consultar o saldo

        - Uma das diferenças entre da programação OO e a procedural é a quantidade de código escrita, além de vincular as funções ao objeto

    - O encapsulamento pode apresentar dados privados ou públicos:
        - private: utilizado para métodos e atributos, permitindo o acesso somente pelo objeto através de getters e setters

        - protect: utilizado para dados protegidos

        - public: utilizado para métodos e atributos

    - A herança também é conhecida por classe pai, classe mãe, super classe ou classes e subclasses:
        - A ideia da herança é atribuir atributos e métodos que sejam comuns entre classes diferentes:
          - class Animal
          - class Cachorro
          - class Gato
        
        - Para implementar uma super classe é necessário utilizar a palavra "extends":
          - class Cachorro extends Animal {}
          - Dessa forma é possível utilizar atributos e métodos da classe pai

        - Utilização do operador super() para referenciar os dados da super classe:
          - super() só é utilizado em classes que recebem herança e pode utilizar parâmetros
          
          - class Cachorro extends Animal {
              constructor() {
                super()
                this.nome = "Doguinho"
              }
            }